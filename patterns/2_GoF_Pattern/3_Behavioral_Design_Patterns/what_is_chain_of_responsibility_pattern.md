<!-- pattern_name: Chain of Responsibility -->

## **1. 패턴 이름 (Pattern Name)**

**Chain of Responsibility (책임 연쇄 패턴)**  
한 줄 소개: **요청을 처리할 수 있는 객체들을 체인으로 연결해, 하나의 객체가 처리하지 못하면 다음 객체로 요청을 전달하는 행동 패턴**

## **2. 문제와 해결 시나리오 (Problem & Use Case)**

- **문제**: 요청을 처리할 객체를 고정하거나 조건문으로 나열하면, 코드 변경에 취약하고 유연성이 떨어짐  
- **해결**: 요청을 처리할 수 있는 객체들을 체인으로 연결하고, 처리 가능 여부에 따라 순차적으로 위임

**적용 상황 예시**:
- 고객 센터에서 요청을 담당자 → 매니저 → 관리자 순으로 위임  
- 이벤트 처리(iOS의 Responder Chain)  
- 웹 요청 필터(미들웨어 체인)  
- 로깅 시스템(Console → File → Remote)

## **3. 구조 (Structure)**

![책임 연쇄 구조](https://github.com/hyunwook13/Pattern/blob/main/assets/chain_of_responsibility.jpeg)

## **4. 참여자 (Participants)**

단계   | 설명                                        | 참여자  
--------|---------------------------------------------|------------------  
1단계  | 처리 가능한 요청을 정의하는 인터페이스         | Handler  
2단계  | 요청을 처리하거나 다음 핸들러로 넘기는 객체     | ConcreteHandler  
3단계  | 실제 요청을 발생시키는 클라이언트               | Client

## **5. 예제 코드 (Sample Code)**

🔗 [예시 코드](https://github.com/hyunwook13/Pattern/tree/main/Example/ChainOfResponsibility)

## **6. 장점 (Pros)**

- **유연한 책임 분산**: 조건문 없이 유연하게 처리 위임  
- **확장성 우수**: 새로운 핸들러 추가가 쉬움 (OCP 만족)  
- **결합도 낮음**: 요청 발신자와 수신자 간 직접 연결이 없음

## **7. 단점 (Cons)**

- **디버깅 어려움**: 어디서 처리됐는지 추적하기 힘듦  
- **불확실한 처리 보장**: 모든 핸들러가 처리 못하면 요청이 유실될 수 있음

## **8. 결과 (Consequences)**

- **처리 로직의 책임을 분리**해 코드 유지보수성 향상  
- **핸들러 간 동적인 연결 가능성** (실행 중 구성도 가능)  
- 체인을 구성하는 방식에 따라 다양한 로직 커스터마이징 가능

## **9. 변형 및 대안 (Variations & Alternatives)**

- **브랜치 체인**: 하나의 핸들러가 여러 분기 경로로 요청을 전달  
- **불변 체인**: 체인 변경 없이 요청만 전달 (함수형 구조에서 자주 사용)  
- **조건 기반 체인 생성기**: 체인을 DSL처럼 설정 가능한 구조로 구현

## **10. 구현 시 주의사항 (Implementation Tips)**

- `nextHandler`를 직접 노출하지 말고, `setNext()`로 연결하도록 제한  
- 요청을 처리했는지 여부를 반환해 누락된 처리 방지  
- 단일 책임 원칙을 지켜, 각 핸들러는 특정 타입만 처리

## **11. 관련 패턴 (Related Patterns)**

- **Command**: 요청을 객체로 캡슐화하지만, 처리는 명령에 따라 고정됨  
- **Decorator**: 실행 흐름을 연결한다는 점은 유사하지만, 구조 목적은 다름  
- **Composite**: 복잡한 요청 구조를 처리할 때 함께 사용 가능
