<!-- pattern_name: Mediator -->

## **1. 패턴 이름 (Pattern Name)**

**Mediator (중재자) 패턴**

한 줄 소개: **객체 간 직접 통신을 피하고, 중재자를 통해 간접적으로 상호작용하게 하여 결합도를 줄이는 패턴**

## **2. 문제와 해결 시나리오 (Problem & Use Case)**

- **문제**: 여러 객체(컴포넌트)들이 서로 직접 연결되어 있으면, 상호작용이 많아질수록 구조가 복잡하고 유지보수가 어려워짐.
  
- **해결**: 중재자(Mediator)를 두어 객체 간의 통신을 중재자에게 위임하고, 모든 상호작용을 중앙에서 관리함.
  
- **적용 상황 예시**:
  - 로그인 폼의 입력 필드 간 상태 조정
  - 채팅방에서 사용자 간 메시지 중재
  - 항공 관제 시스템 (여러 비행기 간 직접 통신 대신 관제탑 중재)
  - 컴포넌트 기반 UI에서 View 간 이벤트 전달


## **3. 구조 (Structure)**

![중재자 구조](https://github.com/hyunwook13/Pattern/blob/main/assets/mediator.jpeg)


## **4. 참여자 (Participants)**

| 단계 | 설명 | 참여자 |
|------|------|--------|
| 1단계 | 중재자 인터페이스 정의 (컴포넌트 간 통신 API 제공) | Mediator |
| 2단계 | 실제 로직을 구현하는 중재자 객체 | ConcreteMediator |
| 3단계 | 중재자와 연결되는 공통 컴포넌트 인터페이스 | Colleague |
| 4단계 | 구체적인 컴포넌트 (입력 필드, 버튼 등) | ConcreteColleagueA / B / ... |
| 5단계 | 클라이언트가 컴포넌트와 중재자를 연결 | Client |


## **5. 예제 코드 (Sample Code)**

🔗 [예시 코드](https://github.com/hyunwook13/Pattern/tree/main/Example/Mediator)


## **6. 장점 (Pros)**

- 객체 간의 **결합도 감소** – 직접 연결 대신 중재자를 통해 간접 연결
- 로직의 **중앙 집중화** – 흐름을 하나의 객체에서 관리 가능
- **변경 영향 최소화** – 한 컴포넌트 변경 시 다른 컴포넌트 영향 최소화


## **7. 단점 (Cons)**

- **중재자 과도 집중** – 복잡한 로직이 중재자에 집중되면 관리 어려움
- **모든 컴포넌트가 중재자를 알아야 함** – 일종의 간접 의존성 발생
- **확장성 한계** – 중재자의 책임이 커질수록 모듈화 저하 가능

## **8. 결과 (Consequences)**

- **상호작용이 많을수록 효과적**
- 객체 간 직접 연결이 불가피한 상황에는 비효율적일 수 있음
- 시스템 흐름이 **명확해짐 vs 중재자 유지관리 비용** 증가 가능성


## **9. 변형 및 대안 (Variations & Alternatives)**

- **EventBus / NotificationCenter**: 중재자 분산화 → 느슨한 결합
- **Observer Pattern**: 중재자 없이도 간접적 통신 가능 (1:N 구조)
- **Command + Mediator**: 명령 전달도 중재자 경유


## **10. 구현 시 주의사항 (Implementation Tips)**

- 중재자의 책임을 작게 나누기 → 다수의 작은 Mediator 구성 고려
- **대화형 UI**처럼 복잡한 입력 간 동기화에 효과적
- 너무 많은 의존성을 몰아넣지 않도록 구조 유지


## **11. 관련 패턴 (Related Patterns)**

- **Observer** – 간접 통신이 유사하지만, 중재자 없이 1:N
- **Command** – 명령을 객체화하여 중재자에게 위임
- **Facade** – 내부 복잡성 은닉 목적이 비슷하나 의존성 방향이 다름
