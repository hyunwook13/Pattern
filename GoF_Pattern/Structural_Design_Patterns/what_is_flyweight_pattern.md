<!-- pattern_name: Flyweight -->

## 1. 패턴 이름 (Pattern Name)

**Flyweight (플라이웨이트) 패턴**  
한 줄 소개: 동일하거나 유사한 객체를 공유해 메모리 사용을 최소화하는 구조적 디자인 패턴

---

## 2. 문제와 해결 시나리오 (Problem & Use Case)

- **문제:** 대량의 유사 객체를 생성할 때 **메모리 낭비**가 발생하며 성능 문제가 생김  
- **적용 상황 예시:**
  - 게임에서 수천 개의 총알, 적 캐릭터 등의 공통 속성을 공유할 때
  - 문서 편집기에서 문자(글꼴, 색상 등)와 같은 반복 요소를 표현할 때
  - 지도를 렌더링할 때 동일한 아이콘을 수백, 수천 개 뿌릴 때

---

## 3. 구조 (Structure)

- **플라이웨이트 구조 다이어그램:**  
  ![Flyweight 구조](https://github.com/hyunwook13/Pattern/blob/main/assets/flyweight.jpeg)

---

## 4. 참여자 (Participants)

| 단계   | 설명                                              | 참여자              |
|--------|---------------------------------------------------|---------------------|
| 1단계  | 클라이언트가 요청한 객체의 공통 속성을 정의       | `Flyweight`         |
| 2단계  | 공통 속성을 갖는 실제 객체 구현                   | `ConcreteFlyweight` |
| 3단계  | 고유한 속성은 외부에서 전달 (Extrinsic state)     | `Client`            |
| 4단계  | 객체를 캐싱하거나 재사용하는 팩토리               | `FlyweightFactory`  |

---

## 5. 예제 코드 (Sample Code)

[예시 코드](https://github.com/hyunwook13/Pattern/blob/main/Example/Flyweight "예시 코드")

---

## 6. 장점 (Pros)

- 메모리 사용량을 획기적으로 줄일 수 있음  
- 중복 인스턴스 생성을 방지해 성능 최적화 가능  
- 동일 객체의 재사용으로 생성 비용 절감  

---

## 7. 단점 (Cons)

- 외부 상태(고유 정보)를 따로 관리해야 하므로 코드 복잡도 증가  
- Flyweight 객체가 너무 많아지면 Factory 관리가 어려워질 수 있음  
- 공유된 객체에 부작용이 생기지 않도록 설계 주의 필요  

---

## 8. 결과 (Consequences)

- 대량의 객체를 생성해야 하는 경우에서도 시스템이 고성능을 유지할 수 있음  
- 외부 상태와 내부 상태를 명확히 구분하여 설계해야 유지보수가 쉬움  

---

## 9. 변형 및 대안 (Variations & Alternatives)

- **Immutable 객체와의 결합**: 플라이웨이트는 종종 불변 객체로 구현  
- **캐시 패턴과 조합**: Factory 내에서 LRU 캐시를 써서 객체 생명주기 최적화  
- **동적 로딩 플라이웨이트**: 필요할 때만 로딩해 무거운 객체도 효율적으로 관리  

---

## 10. 적용 시 주의사항 (Implementation Tips)

- 내부 상태(공통 속성)와 외부 상태(고유 속성)를 **명확히 분리**  
- 객체가 정말 공유 가능한지 여부를 잘 판단해야 함  
- Factory는 재사용 가능한 객체만 반환하도록 설계  

---

## 11. 관련 패턴 (Related Patterns)

- **Factory Method**: Flyweight 객체의 생성을 캡슐화  
- **Prototype**: 공유하지 않고도 유사 객체를 빠르게 복제  
- **Object Pool**: 사용 후 반납되는 방식으로 객체 재사용
